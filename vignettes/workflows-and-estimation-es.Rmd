---
title: "Flujos de Trabajo y Estimacion (ES)"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Flujos de Trabajo y Estimacion (ES)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE
)
```

## Que es un Workflow?

Luego de transformar los datos de la encuesta con steps y recipes, la siguiente tarea es
la **estimacion**: calcular medias, totales, razones y sus errores estandar
teniendo en cuenta el diseno complejo de la encuesta.

La funcion `workflow()` envuelve los estimadores del paquete `survey`
(`svymean`, `svytotal`, `svyratio`, `svyby`) y devuelve resultados ordenados en formato `data.table`
que incluyen:

- Estimaciones puntuales y errores estandar
- Coeficientes de variacion (CV)
- Intervalos de confianza
- Metadatos para la reproducibilidad

## Configuracion inicial

Utilizamos el conjunto de datos Academic Performance Index (API) del paquete `survey`,
que contiene datos reales de escuelas estratificadas de California.

```{r setup}
library(metasurvey)
library(survey)
library(data.table)

data(api, package = "survey")
dt <- data.table(apistrat)

svy <- Survey$new(
  data    = dt,
  edition = "2000",
  type    = "api",
  psu     = NULL,
  engine  = "data.table",
  weight  = add_weight(annual = "pw")
)
```

## Estimacion basica

### Media

Estimamos la media poblacional del puntaje API en el ano 2000:

```{r mean}
result <- workflow(
  list(svy),
  survey::svymean(~api00, na.rm = TRUE),
  estimation_type = "annual"
)

result
```

### Total

Estimamos la matriculacion total en todas las escuelas:

```{r total}
result_total <- workflow(
  list(svy),
  survey::svytotal(~enroll, na.rm = TRUE),
  estimation_type = "annual"
)

result_total
```

### Multiples estimaciones a la vez

Es posible pasar varias llamadas de estimacion a `workflow()` para calcularlas en un
unico paso:

```{r multiple}
results <- workflow(
  list(svy),
  survey::svymean(~api00, na.rm = TRUE),
  survey::svytotal(~enroll, na.rm = TRUE),
  estimation_type = "annual"
)

results
```

## Estimacion por dominio

Utilizamos `survey::svyby()` para calcular estimaciones por subpoblaciones (dominios):

```{r domain}
# Mean API score by school type
api_by_type <- workflow(
  list(svy),
  survey::svyby(~api00, ~stype, survey::svymean, na.rm = TRUE),
  estimation_type = "annual"
)

api_by_type
```

```{r domain-award}
# Mean enrollment by awards status
enroll_by_award <- workflow(
  list(svy),
  survey::svyby(~enroll, ~awards, survey::svymean, na.rm = TRUE),
  estimation_type = "annual"
)

enroll_by_award
```

## Evaluacion de la calidad

El **coeficiente de variacion (CV)** mide la precision de la estimacion. Se puede utilizar
`evaluate_cv()` para clasificar la calidad siguiendo las directrices estandar:

| Rango de CV | Calidad | Recomendacion |
|-------------|---------|---------------|
| < 5%        | Excelente | Usar sin restricciones |
| 5-10%       | Muy buena | Usar con confianza |
| 10-15%      | Buena | Usar para la mayoria de los propositos |
| 15-25%      | Aceptable | Usar con precaucion |
| 25-35%      | Deficiente | Solo para tendencias generales |
| >= 35%      | No confiable | No publicar |

```{r cv}
# Evaluate quality of the API score estimate
cv_pct <- results$cv[1] * 100
quality <- evaluate_cv(cv_pct)

cat("CV:", round(cv_pct, 2), "%\n")
cat("Quality:", quality, "\n")
```

## RecipeWorkflow: Estimaciones publicables

Un `RecipeWorkflow` agrupa llamadas de estimacion con metadatos, lo que hace que el
analisis sea reproducible y compartible. Registra:

- Que recipes se utilizaron para la preparacion de los datos
- Que llamadas de estimacion se realizaron
- Informacion de autoria y versionado

### Creacion de un RecipeWorkflow

```{r create-wf}
wf <- RecipeWorkflow$new(
  name = "API Score Analysis 2000",
  description = "Mean API score estimation by school type",
  user = "Research Team",
  survey_type = "api",
  edition = "2000",
  estimation_type = "annual",
  recipe_ids = character(0),
  calls = list(
    "survey::svymean(~api00, na.rm = TRUE)",
    "survey::svyby(~api00, ~stype, survey::svymean, na.rm = TRUE)"
  )
)

wf
```

### Publicacion en el registro

Publicamos el workflow para que otros puedan descubrirlo y reutilizarlo:

```{r wf-registry}
# Configure a local backend
wf_path <- tempfile(fileext = ".json")
set_workflow_backend("local", path = wf_path)

# Publish
publish_workflow(wf)

# Discover workflows
all_wf <- list_workflows()
length(all_wf)

# Search by text
found <- search_workflows("income")
length(found)

# Filter by survey type
ech_wf <- filter_workflows(survey_type = "ech")
length(ech_wf)
```

### Busqueda de workflows asociados a un recipe

Si se dispone de un recipe y se desea conocer que estimaciones han sido publicadas
para el mismo, se puede utilizar `find_workflows_for_recipe()`:

```{r find-for-recipe}
# Create a workflow that references a recipe
wf2 <- RecipeWorkflow$new(
  name            = "Labor Market Estimates",
  user            = "Team",
  survey_type     = "ech",
  edition         = "2023",
  estimation_type = "annual",
  recipe_ids      = c("labor_force_recipe_001"),
  calls           = list("survey::svymean(~employed, na.rm = TRUE)")
)

publish_workflow(wf2)

# Find all workflows that use this recipe
related <- find_workflows_for_recipe("labor_force_recipe_001")
length(related)
if (length(related) > 0) cat("Found:", related[[1]]$name, "\n")
```

## Compartir mediante la API remota

Para una difusion mas amplia, es posible publicar workflows en la API de metasurvey:

```{r api-wf, eval = FALSE}
# Requires authentication
api_login("you@example.com", "password")

# Publish
api_publish_workflow(wf)

# Browse
all <- api_list_workflows(survey_type = "ech")
specific <- api_get_workflow("workflow_id_here")
```

## Pipeline completo

A continuacion se presenta un pipeline completo desde los datos crudos hasta la estimacion
publicable, utilizando el conjunto de datos API:

```{r full-pipeline}
# 1. Create survey from real data
dt_full <- data.table(apistrat)

svy_full <- Survey$new(
  data    = dt_full,
  edition = "2000",
  type    = "api",
  psu     = NULL,
  engine  = "data.table",
  weight  = add_weight(annual = "pw")
)

# 2. Apply steps: compute derived variables
svy_full <- step_compute(svy_full,
  api_growth = api00 - api99,
  high_growth = ifelse(api00 - api99 > 50, 1L, 0L),
  comment = "API score growth indicators"
)

svy_full <- step_recode(svy_full, school_level,
  stype == "E" ~ "Elementary",
  stype == "M" ~ "Middle",
  stype == "H" ~ "High",
  .default = "Other",
  comment = "School level classification"
)

# 3. Estimate means
estimates <- workflow(
  list(svy_full),
  survey::svymean(~api_growth, na.rm = TRUE),
  survey::svymean(~high_growth, na.rm = TRUE),
  estimation_type = "annual"
)

estimates
```

```{r full-pipeline-domain}
# 4. Domain estimation (by school type)
by_school <- workflow(
  list(svy_full),
  survey::svyby(~api00, ~stype, survey::svymean, na.rm = TRUE),
  estimation_type = "annual"
)

by_school
```

```{r full-pipeline-cv}
# 5. Assess quality
for (i in seq_len(nrow(estimates))) {
  cv_val <- estimates$cv[i] * 100
  cat(
    estimates$stat[i], ":",
    round(cv_val, 1), "% CV -",
    evaluate_cv(cv_val), "\n"
  )
}
```

## Proximos pasos

- **[Creacion y publicacion de Recipes](recipes.html)** -- Construir pipelines de transformacion reproducibles
- **[Disenos de encuesta y validacion](complex-designs.html)** -- Estratificacion, conglomerados, pesos replicados
- **[Estudio de caso: ECH](ech-case-study.html)** -- Analisis completo del mercado laboral con estimacion
