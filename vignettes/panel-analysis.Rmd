---
title: "Panel Survey Analysis with metasurvey"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Panel Survey Analysis with metasurvey}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE,
  eval = FALSE
)
```

```{r setup}
library(metasurvey)
library(survey)
library(magrittr)
library(data.table)
library(ggplot2)
```

## Introduction

Panel surveys follow the same respondents over time, providing rich data for analyzing change and trends. The `metasurvey` package provides specialized tools for working with rotative panel surveys, which are common in official statistics.

This vignette demonstrates:
- Loading and structuring panel survey data
- Working with implantation and follow-up periods
- Handling different weight structures for different time periods
- Analyzing transitions and changes over time
- Managing complex variance estimation with panel data

## Understanding Rotative Panel Surveys

Rotative panel surveys have two main components:

1. **Implantation**: Initial interviews establishing the panel
2. **Follow-up**: Subsequent interviews tracking changes

The Uruguayan ECH (Encuesta Continua de Hogares) is a typical example with quarterly implantation and monthly follow-ups.

## Loading Panel Survey Data

### Basic Panel Structure

```{r basic-panel}
# Example directory structure for panel data
# ech_2023/
#   ├── ECH_implantacion_2023.csv
#   └── seguimiento/
#       ├── ECH_2023_01.csv
#       ├── ECH_2023_02.csv
#       ├── ...
#       └── ECH_2023_12.csv

# Load panel survey with different weights for each component
panel_survey <- load_panel_survey(
  path_implantation = "data/ECH_implantacion_2023.csv",
  path_follow_up = "data/seguimiento/",
  svy_type = "ECH_2023",
  svy_weight_implantation = add_weight(
    annual = "W_ANO" # annual weights for cross-sectional analysis
  ),
  svy_weight_follow_up = add_weight(
    monthly = "W" # monthly weights for timely estimates
  )
)

# Examine panel structure
print(panel_survey)
```

### Panel with Bootstrap Replicates

For robust variance estimation, especially important with panel data:

```{r panel-bootstrap}
panel_with_bootstrap <- load_panel_survey(
  path_implantation = "data/ECH_implantacion_2023.csv",
  path_follow_up = "data/seguimiento/",
  svy_type = "ECH_2023",
  svy_weight_implantation = add_weight(
    annual = add_replicate(
      "W_ANO",
      replicate_path = "data/bootstrap_annual_2023.csv",
      replicate_id = c("ID" = "ID"),
      replicate_pattern = "wr[0-9]+",
      replicate_type = "bootstrap"
    )
  ),
  svy_weight_follow_up = add_weight(
    monthly = add_replicate(
      "W",
      replicate_path = c(
        "data/bootstrap_monthly_jan_jun_2023.csv",
        "data/bootstrap_monthly_jul_dec_2023.csv"
      ),
      replicate_id = c("ID" = "ID"),
      replicate_pattern = "wr[0-9]+",
      replicate_type = "bootstrap"
    )
  )
)
```

## Working with Panel Data Levels

Panel surveys require specifying which level of data to use for each operation:

### Level-Specific Operations

```{r level-operations}
# Create variables for different analysis levels
processed_panel <- panel_survey %>%
  # Annual variables (implantation level)
  step_recode(
    "education_level",
    years_education >= 16 ~ "University",
    years_education >= 12 ~ "Secondary",
    years_education >= 6 ~ "Primary",
    .default = "Less than Primary",
    comment = "Educational attainment categories",
    .level = "implantation" # only available in implantation
  ) %>%
  # Monthly labor force variables (follow-up level)
  step_recode(
    "employed",
    employment_status == 1 ~ 1,
    .default = 0,
    comment = "Employment indicator",
    .level = "follow_up" # available in all follow-up periods
  ) %>%
  step_recode(
    "unemployed",
    employment_status == 2 ~ 1,
    .default = 0,
    comment = "Unemployment indicator",
    .level = "follow_up"
  ) %>%
  # Computed variables
  step_compute(
    labor_force = employed + unemployed,
    unemployment_rate = unemployed / labor_force,
    comment = "Labor force indicators",
    .level = "follow_up"
  )

# View processing steps by level
processed_panel$get_steps()
```

### Auto-Level Detection

The package can automatically determine the appropriate level:

```{r auto-level}
# Using .level = "auto" (default)
auto_processed <- panel_survey %>%
  step_compute(
    # Available in both levels - applied to both
    age_squared = age^2,
    comment = "Age squared for modeling",
    .level = "auto"
  ) %>%
  step_recode(
    "adult",
    age >= 18 ~ 1,
    .default = 0,
    comment = "Adult indicator",
    .level = "auto" # applied to appropriate level(s)
  )
```

## Panel Data Analysis Patterns

### Cross-Sectional Analysis

Using implantation data for annual estimates:

```{r cross-sectional}
# Apply steps and analyze implantation data
baked_panel <- bake_steps(processed_panel)

# Annual cross-sectional estimates
annual_results <- workflow(
  survey = list(baked_panel$implantation),
  survey::svymean(~education_level, na.rm = TRUE),
  survey::svytotal(~adult),
  estimation_type = "annual"
)

print(annual_results)
```

### Time Series Analysis

Using follow-up data for monthly trends:

```{r time-series}
# Extract monthly surveys for time series
monthly_surveys <- extract_surveys(baked_panel, monthly = 1:12)

# Monthly labor force estimates
monthly_results <- workflow(
  survey = monthly_surveys,
  survey::svymean(~unemployment_rate, na.rm = TRUE),
  survey::svytotal(~employed),
  survey::svytotal(~unemployed),
  estimation_type = "monthly"
)

# Add time identifiers
monthly_results[, month := rep(1:12, each = .N / 12)]

# Plot unemployment rate over time
unemployment_trend <- monthly_results[stat == "unemployment_rate"]

ggplot(unemployment_trend, aes(x = month, y = value)) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = confint_lower, ymax = confint_upper), alpha = 0.3) +
  scale_y_continuous(labels = scales::percent_format()) +
  labs(
    title = "Monthly Unemployment Rate",
    subtitle = "With 95% confidence intervals",
    x = "Month",
    y = "Unemployment Rate"
  ) +
  theme_minimal()
```

### Quarterly to Monthly Estimation

A key feature for official statistics - producing monthly estimates from quarterly samples:

```{r quarterly-monthly}
# Extract quarterly implantation surveys
quarterly_surveys <- extract_surveys(baked_panel, quarterly = 1:4)

# Quarterly to monthly estimation with correlation adjustment
qm_results <- workflow(
  survey = quarterly_surveys,
  survey::svymean(~unemployment_rate, na.rm = TRUE),
  survey::svyratio(~unemployed, ~labor_force),
  estimation_type = "quarterly:monthly", # special notation
  rho = 0.5, # correlation between quarters
  R = 5 / 6 # overlap ratio
)

print(qm_results)
```

## Transition Analysis

Analyzing changes between time periods:

### Individual-Level Transitions

```{r transitions}
# Create transition indicators
transition_panel <- baked_panel %>%
  step_compute(
    # Compare employment status between periods
    employed_t1 = employed_january, # employment in period 1
    employed_t2 = employed_february, # employment in period 2
    # Transition categories
    job_to_job = employed_t1 == 1 & employed_t2 == 1,
    job_to_unemployed = employed_t1 == 1 & employed_t2 == 0,
    unemployed_to_job = employed_t1 == 0 & employed_t2 == 1,
    unemployed_to_unemployed = employed_t1 == 0 & employed_t2 == 0,
    comment = "Employment transitions between months",
    .level = "follow_up"
  )

# Estimate transition probabilities
transition_results <- workflow(
  survey = list(transition_panel$follow_up$february), # use second period
  survey::svymean(~job_to_job, na.rm = TRUE),
  survey::svymean(~job_to_unemployed, na.rm = TRUE),
  survey::svymean(~unemployed_to_job, na.rm = TRUE),
  survey::svymean(~unemployed_to_unemployed, na.rm = TRUE),
  estimation_type = "monthly"
)

# Create transition matrix
transition_matrix <- matrix(
  c(
    transition_results[stat == "job_to_job", value],
    transition_results[stat == "job_to_unemployed", value],
    transition_results[stat == "unemployed_to_job", value],
    transition_results[stat == "unemployed_to_unemployed", value]
  ),
  nrow = 2, byrow = TRUE,
  dimnames = list(
    c("Employed", "Unemployed"),
    c("Employed", "Unemployed")
  )
)

print("Transition Matrix (rows = t1, columns = t2):")
print(round(transition_matrix, 3))
```

### Gross Flows Analysis

```{r gross-flows}
# Gross flows in the labor market
flows_panel <- baked_panel %>%
  step_compute(
    # Entry and exit flows
    entry_employment = employed_t2 == 1 & employed_t1 == 0,
    exit_employment = employed_t2 == 0 & employed_t1 == 1,
    entry_unemployment = unemployed_t2 == 1 & unemployed_t1 == 0,
    exit_unemployment = unemployed_t2 == 0 & unemployed_t1 == 1,
    comment = "Labor market entry and exit flows",
    .level = "follow_up"
  )

# Estimate gross flows
flows_results <- workflow(
  survey = list(flows_panel$follow_up$february),
  survey::svytotal(~entry_employment),
  survey::svytotal(~exit_employment),
  survey::svytotal(~entry_unemployment),
  survey::svytotal(~exit_unemployment),
  estimation_type = "monthly"
)

print(flows_results)
```

## Variance Estimation in Panel Data

### Accounting for Panel Correlation

Panel data requires special variance estimation due to correlation between observations:

```{r panel-variance}
# Method 1: Using bootstrap replicates (recommended)
bootstrap_results <- workflow(
  survey = list(panel_with_bootstrap$follow_up$january),
  survey::svymean(~unemployment_rate, na.rm = TRUE),
  estimation_type = "monthly"
)

# Method 2: Adjusting for correlation in quarterly-to-monthly estimation
adjusted_results <- workflow(
  survey = quarterly_surveys,
  survey::svymean(~unemployment_rate, na.rm = TRUE),
  estimation_type = "quarterly:monthly",
  rho = 0.6, # estimated correlation
  R = 5 / 6 # overlap ratio
)

# Compare standard errors
data.table(
  method = c("Bootstrap", "Correlation Adjusted"),
  se = c(bootstrap_results$se, adjusted_results$se),
  cv = c(bootstrap_results$cv, adjusted_results$cv)
)
```

### Longitudinal Variance Components

```{r longitudinal-variance}
# Variance decomposition for panel estimates
# This would typically be done with specialized functions

# Between-individual variance component
between_var <- workflow(
  survey = list(baked_panel$implantation),
  survey::svyvar(~mean_unemployment_rate_individual),
  estimation_type = "annual"
)

# Within-individual variance component
within_var <- workflow(
  survey = monthly_surveys,
  survey::svyvar(~unemployment_rate),
  estimation_type = "monthly"
)

# Total variance = between + within
var_components <- data.table(
  component = c("Between", "Within", "Total"),
  variance = c(
    between_var$value,
    within_var$value,
    between_var$value + within_var$value
  )
)

print(var_components)
```

## Quality Assessment for Panel Data

### Panel Attrition Analysis

```{r attrition}
# Analyze response patterns across waves
attrition_panel <- panel_survey %>%
  step_compute(
    responded_wave1 = !is.na(employment_status_jan),
    responded_wave2 = !is.na(employment_status_feb),
    responded_wave3 = !is.na(employment_status_mar),
    # Attrition patterns
    complete_panel = responded_wave1 & responded_wave2 & responded_wave3,
    early_dropout = responded_wave1 & !responded_wave2,
    late_dropout = responded_wave1 & responded_wave2 & !responded_wave3,
    comment = "Panel response patterns",
    .level = "follow_up"
  )

# Estimate attrition rates
attrition_results <- workflow(
  survey = list(attrition_panel$follow_up$march),
  survey::svymean(~complete_panel),
  survey::svymean(~early_dropout),
  survey::svymean(~late_dropout),
  estimation_type = "monthly"
)

print("Attrition Analysis:")
print(attrition_results[, .(stat, rate = value, cv)])
```

### Rotation Group Effects

```{r rotation-effects}
# Analyze differences between rotation groups
rotation_panel <- panel_survey %>%
  step_recode(
    "rotation_group",
    quarter_entered == 1 ~ "Q1",
    quarter_entered == 2 ~ "Q2",
    quarter_entered == 3 ~ "Q3",
    quarter_entered == 4 ~ "Q4",
    comment = "Rotation group classification",
    .level = "implantation"
  )

# Test for rotation group effects
rotation_results <- workflow(
  survey = list(rotation_panel$implantation),
  survey::svyby(~unemployment_rate, ~rotation_group, survey::svymean),
  estimation_type = "annual"
)

# Statistical test for differences would be done separately
print("Unemployment by Rotation Group:")
print(rotation_results)
```

## Advanced Panel Techniques

### Seasonal Adjustment

```{r seasonal}
# Create seasonal indicators for adjustment
seasonal_panel <- baked_panel %>%
  step_recode(
    "season",
    month %in% c(12, 1, 2) ~ "Summer",
    month %in% c(3, 4, 5) ~ "Autumn",
    month %in% c(6, 7, 8) ~ "Winter",
    month %in% c(9, 10, 11) ~ "Spring",
    comment = "Seasonal classification",
    .level = "follow_up"
  )

# Estimate seasonal patterns
seasonal_results <- workflow(
  survey = monthly_surveys,
  survey::svyby(~unemployment_rate, ~season, survey::svymean),
  estimation_type = "monthly"
)

print("Seasonal Unemployment Patterns:")
print(seasonal_results)
```

### Cohort Analysis

```{r cohort}
# Define birth cohorts for analysis
cohort_panel <- baked_panel %>%
  step_compute(
    birth_year = current_year - age,
    comment = "Calculate birth year",
    .level = "implantation"
  ) %>%
  step_recode(
    "birth_cohort",
    birth_year >= 1990 ~ "Millennials",
    birth_year >= 1980 ~ "Gen X",
    birth_year >= 1960 ~ "Baby Boomers",
    .default = "Silent Generation",
    comment = "Birth cohort classification",
    .level = "implantation"
  )

# Analyze unemployment by cohort over time
cohort_results <- workflow(
  survey = monthly_surveys,
  survey::svyby(~unemployment_rate, ~birth_cohort, survey::svymean),
  estimation_type = "monthly"
)

# This would produce results for each month and cohort
print("Cohort Analysis Results (sample):")
print(head(cohort_results))
```

## Panel Data Best Practices

### 1. Weight Selection
```{r bp-weights}
# Use appropriate weights for analysis type:
# - Cross-sectional: implantation weights
# - Time series: follow-up weights
# - Transitions: follow-up weights with adjustments
```

### 2. Missing Data Handling
```{r bp-missing}
# Account for panel attrition in analysis
# Consider weighting adjustments for nonresponse
# Use multiple imputation for item nonresponse
```

### 3. Temporal Alignment
```{r bp-temporal}
# Ensure variables are measured at correct time points
# Account for reference period differences
# Consider lag structures in relationships
```

### 4. Variance Estimation
```{r bp-variance}
# Use bootstrap replicates when available
# Adjust for correlation in overlapping samples
# Consider design effects in panel context
```

### 5. Quality Monitoring
```{r bp-quality}
# Monitor response rates over time
# Check for rotation group effects
# Validate key estimates against external sources
```

## Conclusion

Panel surveys provide rich opportunities for understanding change and dynamics in populations. The `metasurvey` package provides tools to handle the complexity of panel data while maintaining statistical rigor in estimation and inference.

Key takeaways:
- Use appropriate data levels for different analysis types
- Account for panel correlation in variance estimation
- Monitor data quality throughout the panel lifecycle
- Leverage the full time dimension of the data for insights not available from cross-sections

The next vignette will cover creating and using recipes to make panel analysis workflows reusable and reproducible.
