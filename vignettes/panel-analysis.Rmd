---
title: "Panel Survey Analysis with metasurvey"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Panel Survey Analysis with metasurvey}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE
)
```

## Introduction

Many national household surveys use **rotative panel designs**, where a sample
of respondents is interviewed in an initial wave (*implantation*) and then
followed up over successive periods. metasurvey provides two classes for this
setting:
- `RotativePanelSurvey` -- a panel with an implantation survey and a list of
  follow-up surveys.
- `PoolSurvey` -- a collection of surveys pooled together for combined
  estimation.

## Creating a RotativePanelSurvey

A `RotativePanelSurvey` requires an implantation `Survey` and one or more
follow-up `Survey` objects. Each component survey must have its `periodicity`
field set.

```{r create-panel}
library(metasurvey)
library(data.table)

set.seed(42)
n <- 100

make_survey <- function(edition) {
  dt <- data.table(
    id       = 1:n,
    age      = sample(18:80, n, replace = TRUE),
    income   = round(runif(n, 500, 8000)),
    employed = sample(0:1, n, replace = TRUE),
    w        = round(runif(n, 0.5, 3.0), 4)
  )
  svy <- Survey$new(
    data = dt, edition = edition, type = "ech",
    psu = NULL, engine = "data.table",
    weight = add_weight(annual = "w")
  )
  svy$periodicity <- "monthly"
  svy
}

# Implantation: January 2023
impl <- make_survey("2023-01-01")

# Follow-ups: February and March 2023
fu_feb <- make_survey("2023-02-01")
fu_mar <- make_survey("2023-03-01")

panel <- RotativePanelSurvey$new(
  implantation   = impl,
  follow_up      = list(fu_feb, fu_mar),
  type           = "ech",
  default_engine = "data.table",
  steps          = list(),
  recipes        = list(),
  workflows      = list(),
  design         = NULL
)
```

## Accessing Panel Components

Use `get_implantation()` and `get_follow_up()` to retrieve the individual
surveys:

```{r access-panel}
# Implantation survey
imp <- get_implantation(panel)
class(imp)
head(get_data(imp), 3)

# Follow-up surveys
follow_ups <- get_follow_up(panel)
length(follow_ups)
```

## Working with Panel Data

You can apply transformations directly on the component surveys. For example,
compute a derived variable on the implantation:

```{r panel-compute}
panel$implantation <- step_compute(panel$implantation,
  income_k = income / 1000
)
panel$implantation <- bake_steps(panel$implantation)

head(get_data(panel$implantation)[, .(id, income, income_k)], 3)
```

Apply the same transformation to each follow-up:

```{r panel-follow-up}
panel$follow_up <- lapply(panel$follow_up, function(svy) {
  svy <- step_compute(svy, income_k = income / 1000)
  bake_steps(svy)
})

head(get_data(panel$follow_up[[1]])[, .(id, income, income_k)], 3)
```

## Running Estimations

Use `workflow()` on individual panel components for cross-sectional or time
series analysis.

### Cross-sectional analysis (implantation)

```{r workflow-impl}
result_impl <- workflow(
  list(panel$implantation),
  survey::svymean(~income, na.rm = TRUE),
  estimation_type = "annual"
)

result_impl
```

### Comparing across follow-ups

```{r workflow-followup}
results <- rbindlist(lapply(seq_along(panel$follow_up), function(i) {
  r <- workflow(
    list(panel$follow_up[[i]]),
    survey::svymean(~income, na.rm = TRUE),
    estimation_type = "annual"
  )
  r$period <- paste0("follow_up_", i)
  r
}))

results[, .(period, stat, value, se, cv)]
```

## Creating a PoolSurvey

A `PoolSurvey` pools multiple surveys together for combined estimation. The
constructor takes a nested list: `list(estimation_type = list(group = list(surveys)))`.

```{r pool-survey}
s1 <- make_survey("2023-01-01")
s1$edition <- "2023-01-01"

s2 <- make_survey("2023-02-01")
s2$edition <- "2023-02-01"

pool <- PoolSurvey$new(
  list(annual = list("group1" = list(s1, s2)))
)

class(pool)
```

Run a pooled estimation:

```{r workflow-pool}
pool_result <- workflow(
  pool,
  survey::svymean(~income, na.rm = TRUE),
  estimation_type = "annual"
)

pool_result
```

## Loading Panel Data from Files

In practice, panel data is loaded from files using `load_panel_survey()`:

```{r load-panel, eval = FALSE}
panel <- load_panel_survey(
  path_implantation = "data/ech_impl_2023.dta",
  path_follow_up    = "data/ech_fu_2023/",
  svy_type          = "ech",
  svy_weight_implantation = add_weight(annual = "pesoano"),
  svy_weight_follow_up    = add_weight(monthly = "pesomes")
)
```

## Best Practices

1. **Set periodicity** on each component survey before constructing the panel.
2. **Apply transformations uniformly** -- ensure the same steps are applied to
   implantation and follow-up surveys for comparability.
3. **Use PoolSurvey** when combining surveys for variance reduction or
   quarterly-to-monthly estimation.
4. **Validate results** -- compare pooled estimates against direct estimates
   to check for consistency.
