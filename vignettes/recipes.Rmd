---
title: "Creating and Using Recipes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Creating and Using Recipes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE
)
```

## What are Recipes?

Recipes are **reusable collections of transformation steps**. They solve a
common problem in survey analysis: applying the same variable construction logic
across different editions of the same survey, or sharing standardised indicator
definitions with collaborators.

A `Recipe` object stores:

- **Metadata** -- name, author, survey type, edition, description.
- **Steps** -- the sequence of transformations (compute, recode, join, etc.).
- **Optional fields** -- DOI for citation, topic for search.

## Creating a Recipe

Use `recipe()` to create an empty recipe with metadata:

```{r recipe-create}
library(metasurvey)
library(data.table)

labor_recipe <- recipe(
  name        = "labor_indicators",
  user        = "analyst_team",
  svy         = survey_empty(type = "ech", edition = "2023"),
  description = "Standard labor force indicators following ILO definitions"
)

class(labor_recipe)
```

## Building a Recipe from Steps

A more common workflow is to develop your transformations on a real survey, then
convert the recorded steps into a recipe with `steps_to_recipe()`.

```{r build-recipe}
set.seed(42)
n <- 100
dt <- data.table(
  id       = 1:n,
  age      = sample(18:80, n, replace = TRUE),
  income   = round(runif(n, 500, 8000)),
  employed = sample(0:1, n, replace = TRUE),
  w        = round(runif(n, 0.5, 3.0), 4)
)

svy <- Survey$new(
  data = dt, edition = "2023", type = "ech",
  psu = NULL, engine = "data.table",
  weight = add_weight(annual = "w")
)

# Develop transformations interactively
svy <- step_compute(svy, income_thousands = income / 1000)
svy <- bake_steps(svy)

# Convert to recipe
my_recipe <- steps_to_recipe(
  name        = "income_prep",
  user        = "analyst",
  svy         = svy,
  description = "Income preparation recipe",
  steps       = get_steps(svy),
  topic       = "income"
)

my_recipe$name
my_recipe$description
length(my_recipe$steps)
```

## Saving and Loading Recipes

Recipes are serialised as JSON for portability.

### Save to file

```{r recipe-save}
tf <- tempfile(fileext = ".json")
save_recipe(my_recipe, tf)
```

### Read from file

```{r recipe-read, eval = FALSE}
loaded_recipe <- read_recipe("my_recipe.json")
```

The JSON format makes recipes easy to version-control in Git and share via
repositories.

## Applying Recipes to a Survey

Once a survey has recipes attached, call `bake_recipes()` to apply all of them:

```{r bake-recipes, eval = FALSE}
# Attach and apply
svy$add_recipe(my_recipe)
processed <- bake_recipes(svy)
```

## Recipe Repository

metasurvey provides an API for sharing recipes with the community. You can
search for existing recipes by survey type, edition, or topic.

### Search for recipes

```{r get-recipe, eval = FALSE}
# Search by survey type and topic
recipes <- get_recipe(
  svy_type = "ech",
  topic    = "labor"
)
```

### Publish a recipe

```{r publish, eval = FALSE}
# Requires API authentication
set_api_key("your-api-key")
publish_recipe(my_recipe)
```

## Validating Recipes

Before applying a recipe to a survey, check compatibility:

```{r validate, eval = FALSE}
validate_recipe(
  svy_type           = "ech",
  svy_edition        = "2023",
  recipe_svy_edition = my_recipe$edition,
  recipe_svy_type    = my_recipe$survey_type
)
```

## Best Practices

1. **Name recipes descriptively** -- include the survey type and topic
   (e.g. `"ech_labor_indicators"`).
2. **Add descriptions** -- document what each recipe computes and why.
3. **Use `topic` and `doi`** -- make recipes discoverable and citable.
4. **Version your recipes** -- save JSON files alongside your analysis code in
   version control.
5. **Test before sharing** -- apply the recipe to sample data and verify the
   output before publishing.
