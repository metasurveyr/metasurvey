---
title: "Sistema AST: El Núcleo de metaSurvey"
author: "metaSurvey Team"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{Sistema AST: El Núcleo de metaSurvey}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE,
  eval = FALSE  # No ejecutar código por ahora - solo mostrar
)
```

# El AST como Núcleo de metaSurvey

El sistema AST (Abstract Syntax Tree) **ES** el motor de evaluación de metaSurvey. No es una característica adicional, sino el núcleo fundamental que ejecuta todas las transformaciones de datos.

## ¿Por qué AST como Núcleo?

```{r intro, eval=TRUE}
library(metasurvey)

# Cada operación en metaSurvey usa AST internamente
cat("metaSurvey usa AST para TODAS las operaciones:\n")
cat("✓ step_compute() → AST parsing → optimization → evaluation\n")
cat("✓ step_recode() → AST parsing → optimization → evaluation\n") 
cat("✓ bake_steps() → AST dependency analysis → optimized execution\n")
```

# Funciones Núcleo del AST

## 1. parse_ast(): Convierte Expresiones a AST

```{r parse_ast}
# Parse expresiones básicas
ast_simple <- parse_ast(quote(age * 12))
print("AST de 'age * 12':")
print(ast_simple)

# Parse expresiones condicionales
ast_conditional <- parse_ast(quote(ifelse(age >= 18, "adult", "minor")))
print("AST de condición:")
str(ast_conditional)

# Parse expresiones complejas
ast_complex <- parse_ast(quote((income / 1000) + (age * 0.1)))
print("AST complejo:")
str(ast_complex)
```

## 2. evaluate_ast(): Ejecuta el AST con Datos

```{r evaluate_ast}
# Datos de prueba
test_data <- data.frame(
  age = c(25, 17, 45, 62),
  income = c(45000, 20000, 75000, 50000)
)

print("Datos de entrada:")
print(test_data)

# Evaluación con AST
result1 <- evaluate_ast(ast_simple, test_data)
print("Resultado 'age * 12':")
print(result1)

result2 <- evaluate_ast(ast_conditional, test_data)
print("Resultado condición:")
print(result2)

result3 <- evaluate_ast(ast_complex, test_data)
print("Resultado complejo:")
print(result3)
```

## 3. optimize_ast(): Optimización Automática

```{r optimize_ast}
# Optimización de constantes
ast_constants <- parse_ast(quote(age * (2 + 3)))
ast_optimized <- optimize_ast(ast_constants)

cat("Original: age * (2 + 3)\n")
cat("Optimizado: age * 5\n")
print("AST Original:")
str(ast_constants)
print("AST Optimizado:")
str(ast_optimized)

# Optimización de condiciones redundantes
ast_redundant <- parse_ast(quote(ifelse(TRUE, income, 0)))
ast_simplified <- optimize_ast(ast_redundant)

cat("\nRedundante: ifelse(TRUE, income, 0)\n")
cat("Simplificado: income\n")
```

## 4. get_ast_dependencies(): Análisis de Dependencias

```{r dependencies}
# Dependencias simples
deps1 <- get_ast_dependencies(ast_simple)
print("Dependencias de 'age * 12':")
print(deps1)

# Dependencias múltiples
expressions <- list(
  step1 = quote(age * 2),
  step2 = quote(step1 + income),
  step3 = quote(step2 / 1000)
)

deps_multiple <- get_ast_dependencies(expressions)
print("Dependencias múltiples:")
print(deps_multiple)
```

# Integración: AST en step_compute()

```{r step_compute}
# Crear datos de prueba
survey_data <- data.frame(
  id = 1:50,
  age = sample(18:80, 50, replace = TRUE),
  income = sample(20000:100000, 50, replace = TRUE)
)

print("Dataset original:")
head(survey_data)

# step_compute usa AST como motor principal
result <- step_compute(survey_data,
  # Transformaciones que van a AST
  age_months = age * 12,
  age_decades = age / 10,
  income_k = income / 1000,
  
  # Condiciones que se optimizan en AST
  age_group = ifelse(age < 30, "young", 
                    ifelse(age < 60, "middle", "older")),
  
  # Habilitar explícitamente las características AST
  optimize_ast = TRUE,
  cache_ast = TRUE,
  validate_deps = TRUE
)

print("Resultado con AST:")
head(result[c("age", "age_months", "age_group", "income_k")])
```

# Integración: AST en step_recode()

```{r step_recode}
# step_recode también usa AST como núcleo
result_recode <- step_recode(survey_data,
  # Recodificaciones que van a AST
  age_category = ifelse(age < 25, "very_young",
                       ifelse(age < 50, "middle_age", "mature")),
  
  income_level = ifelse(income < 40000, "low",
                       ifelse(income < 70000, "medium", "high")),
  
  # El AST optimiza estas transformaciones
  optimize_ast = TRUE,
  cache_ast = TRUE
)

print("Recodificación con AST:")
head(result_recode[c("age", "age_category", "income", "income_level")])
```

# Los 6 Tipos de Optimización AST

## 1. Constant Folding (Plegado de Constantes)

```{r constant_folding}
# AST evalúa constantes en tiempo de compilación
expr_before <- quote(age * (5 + 3) + (10 - 2))
expr_after <- optimize_ast(parse_ast(expr_before))

cat("Antes: age * (5 + 3) + (10 - 2)\n")
cat("Después: age * 8 + 8\n")
```

## 2. Dead Code Elimination (Eliminación de Código Muerto)

```{r dead_code}
# AST elimina código inalcanzable
expr_dead <- quote(ifelse(TRUE, income, unused_var))
expr_clean <- optimize_ast(parse_ast(expr_dead))

cat("Código muerto: ifelse(TRUE, income, unused_var)\n")
cat("Eliminado: income\n")
```

## 3. Expression Simplification (Simplificación)

```{r simplification}
# AST simplifica expresiones algebraicas
expr_complex <- quote(age * 1 + 0 + income * 1)
expr_simple <- optimize_ast(parse_ast(expr_complex))

cat("Complejo: age * 1 + 0 + income * 1\n")
cat("Simple: age + income\n")
```

## 4. Dependency Analysis (Análisis de Dependencias)

```{r dependency_analysis}
# AST ordena evaluaciones automáticamente
complex_deps <- list(
  final = quote(base + bonus),
  base = quote(age * factor),
  factor = quote(income / 50000),
  bonus = quote(ifelse(age > 40, 5, 0))
)

ordered_deps <- get_ast_dependencies(complex_deps)
cat("Orden de evaluación detectado por AST:\n")
for(i in seq_along(ordered_deps)) {
  cat(paste(i, ":", names(ordered_deps)[i], "\n"))
}
```

## 5. Vectorization Optimization (Vectorización)

```{r vectorization}
# AST identifica oportunidades de vectorización
large_data <- data.frame(
  age = sample(18:80, 1000, replace = TRUE),
  income = sample(20000:100000, 1000, replace = TRUE)
)

# Operación vectorizada por AST
start_time <- Sys.time()
vectorized_result <- step_compute(large_data,
  complex_calc = (age * income) / (age + income + 1),
  optimize_ast = TRUE
)
end_time <- Sys.time()

cat("Tiempo con vectorización AST:", 
    as.numeric(end_time - start_time), "segundos\n")
```

## 6. Conditional Optimization (Optimización Condicional)

```{r conditional_optimization}
# AST optimiza condiciones anidadas
nested_cond <- quote(
  ifelse(age < 20, "teen",
    ifelse(age < 30, "twenties", 
      ifelse(age < 50, "adult", "senior")))
)

optimized_cond <- optimize_ast(parse_ast(nested_cond))
cat("AST convierte condiciones anidadas en evaluación optimizada\n")
```

# Beneficios de Rendimiento

```{r performance}
# Comparación con dataset grande
big_data <- data.frame(
  id = 1:5000,
  age = sample(18:80, 5000, replace = TRUE),
  income = sample(20000:100000, 5000, replace = TRUE),
  education = sample(1:5, 5000, replace = TRUE)
)

# Medición de rendimiento con AST
start_time <- Sys.time()
result_optimized <- step_compute(big_data,
  age_score = age / 10,
  income_score = income / 10000,
  education_bonus = education * 2,
  final_score = age_score + income_score + education_bonus,
  
  optimize_ast = TRUE,
  cache_ast = TRUE,
  validate_deps = TRUE
)
end_time <- Sys.time()

cat("Procesamiento de", nrow(big_data), "filas con AST:\n")
cat("Tiempo:", as.numeric(end_time - start_time), "segundos\n")
cat("Variables creadas:", ncol(result_optimized) - ncol(big_data), "\n")
```

# Casos de Uso Avanzados

## Pipeline Complejo

```{r advanced_pipeline}
# Pipeline que aprovecha todo el poder del AST
advanced_result <- step_compute(survey_data,
  # Paso 1: Transformaciones básicas (optimizadas por constant folding)
  age_norm = age / 100,
  income_log = log(income + 1),
  
  # Paso 2: Combinaciones (dependency analysis automático)
  combined_score = age_norm + income_log,
  
  # Paso 3: Categorización (conditional optimization)
  risk_category = ifelse(combined_score < 10, "low",
                        ifelse(combined_score < 15, "medium", "high")),
  
  # Paso 4: Ajustes finales (expression simplification)
  final_score = combined_score * 1.0 + 0,  # AST simplifica a combined_score
  
  optimize_ast = TRUE,
  cache_ast = TRUE,
  validate_deps = TRUE,
  comment = "Pipeline complejo optimizado por AST"
)

print("Pipeline avanzado:")
head(advanced_result[c("age", "income", "combined_score", "risk_category")])
```

## Validación de Errores

```{r validation}
# AST detecta errores antes de evaluación
tryCatch({
  error_result <- step_compute(survey_data,
    var_a = var_b + 1,  # var_b no existe
    var_b = var_a + 1,  # dependencia circular
    validate_deps = TRUE
  )
}, error = function(e) {
  cat("AST detectó error:", e$message, "\n")
})

# AST valida sintaxis
tryCatch({
  syntax_error <- step_compute(survey_data,
    bad_syntax = age +,  # sintaxis inválida
    validate_deps = TRUE
  )
}, error = function(e) {
  cat("AST detectó sintaxis inválida\n")
})
```

# Mejores Prácticas con AST

## 1. Siempre habilitar optimización

```{r bp_optimization}
# BUENA PRÁCTICA: optimize_ast = TRUE
optimized_calc <- step_compute(survey_data,
  result = age * income / 1000,
  optimize_ast = TRUE  # ¡Siempre!
)
```

## 2. Usar cache para cálculos costosos

```{r bp_caching}
# BUENA PRÁCTICA: cache_ast = TRUE para operaciones pesadas
expensive_calc <- step_compute(survey_data,
  complex_stat = age^2 + log(income + 1) + sqrt(abs(age - 40)),
  cache_ast = TRUE  # Cachea resultados intermedios
)
```

## 3. Validar durante desarrollo

```{r bp_validation}
# BUENA PRÁCTICA: validate_deps = TRUE en desarrollo
dev_calc <- step_compute(survey_data,
  step1 = age * 2,
  step2 = step1 + income,
  step3 = step2 / 1000,
  validate_deps = TRUE  # Detecta problemas temprano
)
```

# Conclusión: AST como Núcleo

El sistema AST no es una característica adicional de metaSurvey - **ES metaSurvey**:

1. **Motor Fundamental**: Todas las transformaciones pasan por AST
2. **Optimización Automática**: 6 tipos de optimización sin intervención manual  
3. **Gestión Inteligente**: Dependencias, memoria y errores manejados automáticamente
4. **Escalabilidad**: Desde datasets pequeños hasta grandes
5. **Confiabilidad**: Validación y manejo de errores robusto

El AST garantiza que metaSurvey sea eficiente, confiable y escalable para cualquier análisis de encuestas.
